#!groovy
import uk.gov.hmcts.contino.GithubAPI

properties([
    [
        $class: 'GithubProjectProperty',
        displayName: 'Divorce Case Formatter Service',
        projectUrlStr: 'https://github.com/hmcts/div-case-formatter-service'
    ],
    pipelineTriggers([
        [$class: 'GitHubPushTrigger']
    ])
])

// @Library("Infrastructure")
@Library('Infrastructure@Refactor-GitHubAPI-To-Reduce-API-Calls')

def type = "java"
def product = "div"
def component = "cfs"

def channel = '#div-dev'

def labels = [
    "enable_fortify_scan",
]

def gitHubAPI = new GithubAPI(this)
def repoLabels = gitHubAPI.getLabelsbyPattern(env.BRANCH_NAME, "enable_")

def populateLabelStates(repoLabels, labels) {
    def states = [:]

    // Check existence of provided label, and store in states map
    def getLabelState = { label ->
        if (label == "atLeastOneEnabled") {
            return
        }
        def labelExists = repoLabels.contains(label) ? true : false
        states.put(label, labelExists)
    }

    // Iterate over labels List to build labelStates map
    labels.each { label -> getLabelState(label) }

    // Hardcode enable_all_tests_and_scans label
    if (!states.containsKey("enable_all_tests_and_scans")) {
        getLabelState("enable_all_tests_and_scans")
    }

    // Check if at least one label is true
    states.put("atLeastOneEnabled", states.any {key, value -> value == true })

    return states
}
labelStates = populateLabelStates(repoLabels, labels)

def checkLabel(label) {
    return (labelStates.enable_all_tests_and_scans || labelStates.get(label))
}

def checkLabel2(gitHubAPI, label) {
    def labels = gitHubAPI.getLabelsbyPattern(env.BRANCH_NAME, "enable_")
    echo "Calling getLabelsbyPattern returned: ${labels}"
    echo "Checking labels for: ${label}"
    def labelExists = labels.contains(label)
    echo "Label Exists?: ${labelExists}"
    return labelExists
}

withPipeline(type , product, component) {

    enableAksStagingDeployment()
    disableLegacyDeployment()

    after('checkout') {
        echo '${product}-${component} checked out'
    }

    before('functionalTest:aat') {
        env.test_environment = 'aat'
    }

    after('functionalTest:aat') {
        steps.archiveArtifacts allowEmptyArchive: true, artifacts: '**/site/serenity/**/*'
    }

    // Kubernetes does not retrieve variables from the output terraform
    before('functionalTest:preview') {
        env.test_environment = 'aat'
    }

    after('functionalTest:preview') {
        steps.archiveArtifacts allowEmptyArchive: true, artifacts: '**/site/serenity/**/*'
    }

    enableSlackNotifications(channel)
}

if (checkLabel2(gitHubAPI, "atLeastOneEnabled")) {
    properties([
        parameters([
            string(name: 'URL_TO_TEST', defaultValue: 'http://div-cfs-aat.service.core-compute-aat.internal', description: 'The URL you want to run these tests against')
        ])
    ])

    withNightlyPipeline(type, product, component) {
        onPR() {
            env.TEST_URL = params.URL_TO_TEST
            env.Rules = params.SecurityRules

            if (checkLabel2(gitHubAPI, "enable_fortify_scan")) {
                enableFortifyScan()

                after('fortify-scan') {
                    steps.archiveArtifacts allowEmptyArchive: true, artifacts: '**/Fortify Scan/**/*'
                }
            }
        }
    }
}
